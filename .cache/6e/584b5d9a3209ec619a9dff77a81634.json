{"id":"node_modules/@tonaljs/pcset/dist/index.esnext.js","dependencies":[{"name":"/Users/kozbe/Desktop/playground/music-stuff/node_modules/@tonaljs/pcset/dist/index.esnext.js.map","includedInParent":true,"mtime":499162500000},{"name":"/Users/kozbe/Desktop/playground/music-stuff/package.json","includedInParent":true,"mtime":1570751051894},{"name":"/Users/kozbe/Desktop/playground/music-stuff/node_modules/@tonaljs/pcset/package.json","includedInParent":true,"mtime":1570750957251},{"name":"@tonaljs/array","loc":{"line":1,"column":39},"parent":"/Users/kozbe/Desktop/playground/music-stuff/node_modules/@tonaljs/pcset/dist/index.esnext.js","resolved":"/Users/kozbe/Desktop/playground/music-stuff/node_modules/@tonaljs/array/dist/index.esnext.js"},{"name":"@tonaljs/tonal","loc":{"line":2,"column":31},"parent":"/Users/kozbe/Desktop/playground/music-stuff/node_modules/@tonaljs/pcset/dist/index.esnext.js","resolved":"/Users/kozbe/Desktop/playground/music-stuff/node_modules/@tonaljs/tonal/dist/index.esnext.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.chromaToIntervals = chromaToIntervals;\nexports.chromas = chromas;\nexports.filter = filter;\nexports.isEqual = isEqual;\nexports.isNoteIncludedInSet = isNoteIncludedInSet;\nexports.isSubsetOf = isSubsetOf;\nexports.isSupersetOf = isSupersetOf;\nexports.modes = modes;\nexports.pcset = pcset;\nexports.includes = exports.EmptyPcset = void 0;\n\nvar _array = require(\"@tonaljs/array\");\n\nvar _tonal = require(\"@tonaljs/tonal\");\n\nconst EmptyPcset = {\n  empty: true,\n  name: \"\",\n  setNum: 0,\n  chroma: \"000000000000\",\n  normalized: \"000000000000\",\n  intervals: []\n}; // UTILITIES\n\nexports.EmptyPcset = EmptyPcset;\n\nconst setNumToChroma = num => Number(num).toString(2);\n\nconst chromaToNumber = chroma => parseInt(chroma, 2);\n\nconst REGEX = /^[01]{12}$/;\n\nfunction isChroma(set) {\n  return REGEX.test(set);\n}\n\nconst isPcsetNum = set => typeof set === \"number\" && set >= 0 && set <= 4095;\n\nconst isPcset = set => set && isChroma(set.chroma);\n\nconst cache = {\n  [EmptyPcset.chroma]: EmptyPcset\n};\n/**\r\n * Get the pitch class set of a collection of notes or set number or chroma\r\n */\n\nfunction pcset(src) {\n  const chroma = isChroma(src) ? src : isPcsetNum(src) ? setNumToChroma(src) : Array.isArray(src) ? listToChroma(src) : isPcset(src) ? src.chroma : EmptyPcset.chroma;\n  return cache[chroma] = cache[chroma] || chromaToPcset(chroma);\n}\n\nconst IVLS = \"1P 2m 2M 3m 3M 4P 5d 5P 6m 6M 7m 7M\".split(\" \");\n/**\r\n * @private\r\n * Get the intervals of a pcset *starting from C*\r\n * @param {Set} set - the pitch class set\r\n * @return {IntervalName[]} an array of interval names or an empty array\r\n * if not a valid pitch class set\r\n */\n\nfunction chromaToIntervals(chroma) {\n  const intervals = [];\n\n  for (let i = 0; i < 12; i++) {\n    // tslint:disable-next-line:curly\n    if (chroma.charAt(i) === \"1\") intervals.push(IVLS[i]);\n  }\n\n  return intervals;\n}\n\nlet all;\n/**\r\n * Get a list of all possible pitch class sets (all possible chromas) *having\r\n * C as root*. There are 2048 different chromas. If you want them with another\r\n * note you have to transpose it\r\n *\r\n * @see http://allthescales.org/\r\n * @return {Array<PcsetChroma>} an array of possible chromas from '10000000000' to '11111111111'\r\n */\n\nfunction chromas() {\n  all = all || (0, _array.range)(2048, 4095).map(setNumToChroma);\n  return all.slice();\n}\n/**\r\n * Given a a list of notes or a pcset chroma, produce the rotations\r\n * of the chroma discarding the ones that starts with \"0\"\r\n *\r\n * This is used, for example, to get all the modes of a scale.\r\n *\r\n * @param {Array|string} set - the list of notes or pitchChr of the set\r\n * @param {boolean} normalize - (Optional, true by default) remove all\r\n * the rotations that starts with \"0\"\r\n * @return {Array<string>} an array with all the modes of the chroma\r\n *\r\n * @example\r\n * Pcset.modes([\"C\", \"D\", \"E\"]).map(Pcset.intervals)\r\n */\n\n\nfunction modes(set, normalize = true) {\n  const pcs = pcset(set);\n  const binary = pcs.chroma.split(\"\");\n  return (0, _array.compact)(binary.map((_, i) => {\n    const r = (0, _array.rotate)(i, binary);\n    return normalize && r[0] === \"0\" ? null : r.join(\"\");\n  }));\n}\n/**\r\n * Test if two pitch class sets are numentical\r\n *\r\n * @param {Array|string} set1 - one of the pitch class sets\r\n * @param {Array|string} set2 - the other pitch class set\r\n * @return {boolean} true if they are equal\r\n * @example\r\n * Pcset.isEqual([\"c2\", \"d3\"], [\"c5\", \"d2\"]) // => true\r\n */\n\n\nfunction isEqual(s1, s2) {\n  return pcset(s1).setNum === pcset(s2).setNum;\n}\n/**\r\n * Create a function that test if a collection of notes is a\r\n * subset of a given set\r\n *\r\n * The function is curryfied.\r\n *\r\n * @param {PcsetChroma|NoteName[]} set - the superset to test against (chroma or\r\n * list of notes)\r\n * @return{function(PcsetChroma|NoteNames[]): boolean} a function accepting a set\r\n * to test against (chroma or list of notes)\r\n * @example\r\n * const inCMajor = Pcset.isSubsetOf([\"C\", \"E\", \"G\"])\r\n * inCMajor([\"e6\", \"c4\"]) // => true\r\n * inCMajor([\"e6\", \"c4\", \"d3\"]) // => false\r\n */\n\n\nfunction isSubsetOf(set) {\n  const s = pcset(set).setNum;\n  return notes => {\n    const o = pcset(notes).setNum; // tslint:disable-next-line: no-bitwise\n\n    return s && s !== o && (o & s) === o;\n  };\n}\n/**\r\n * Create a function that test if a collection of notes is a\r\n * superset of a given set (it contains all notes and at least one more)\r\n *\r\n * @param {Set} set - an array of notes or a chroma set string to test against\r\n * @return {(subset: Set): boolean} a function that given a set\r\n * returns true if is a subset of the first one\r\n * @example\r\n * const extendsCMajor = Pcset.isSupersetOf([\"C\", \"E\", \"G\"])\r\n * extendsCMajor([\"e6\", \"a\", \"c4\", \"g2\"]) // => true\r\n * extendsCMajor([\"c6\", \"e4\", \"g3\"]) // => false\r\n */\n\n\nfunction isSupersetOf(set) {\n  const s = pcset(set).setNum;\n  return notes => {\n    const o = pcset(notes).setNum; // tslint:disable-next-line: no-bitwise\n\n    return s && s !== o && (o | s) === o;\n  };\n}\n/**\r\n * Test if a given pitch class set includes a note\r\n *\r\n * @param {Array<string>} set - the base set to test against\r\n * @param {string} note - the note to test\r\n * @return {boolean} true if the note is included in the pcset\r\n *\r\n * Can be partially applied\r\n *\r\n * @example\r\n * const isNoteInCMajor = isNoteIncludedInSet(['C', 'E', 'G'])\r\n * isNoteInCMajor('C4') // => true\r\n * isNoteInCMajor('C#4') // => false\r\n */\n\n\nfunction isNoteIncludedInSet(set) {\n  const s = pcset(set);\n  return noteName => {\n    const n = (0, _tonal.note)(noteName);\n    return s && !n.empty && s.chroma.charAt(n.chroma) === \"1\";\n  };\n}\n/** @deprecated use: isNoteIncludedIn */\n\n\nconst includes = isNoteIncludedInSet;\n/**\r\n * Filter a list with a pitch class set\r\n *\r\n * @param {Array|string} set - the pitch class set notes\r\n * @param {Array|string} notes - the note list to be filtered\r\n * @return {Array} the filtered notes\r\n *\r\n * @example\r\n * Pcset.filter([\"C\", \"D\", \"E\"], [\"c2\", \"c#2\", \"d2\", \"c3\", \"c#3\", \"d3\"]) // => [ \"c2\", \"d2\", \"c3\", \"d3\" ])\r\n * Pcset.filter([\"C2\"], [\"c2\", \"c#2\", \"d2\", \"c3\", \"c#3\", \"d3\"]) // => [ \"c2\", \"c3\" ])\r\n */\n\nexports.includes = includes;\n\nfunction filter(set) {\n  const isIncluded = isNoteIncludedInSet(set);\n  return notes => {\n    return notes.filter(isIncluded);\n  };\n} // PRIVATE //\n\n\nfunction chromaRotations(chroma) {\n  const binary = chroma.split(\"\");\n  return binary.map((_, i) => (0, _array.rotate)(i, binary).join(\"\"));\n}\n\nfunction chromaToPcset(chroma) {\n  const setNum = chromaToNumber(chroma);\n  const normalizedNum = chromaRotations(chroma).map(chromaToNumber).filter(n => n >= 2048).sort()[0];\n  const normalized = setNumToChroma(normalizedNum);\n  const intervals = chromaToIntervals(chroma);\n  return {\n    empty: false,\n    name: \"\",\n    setNum,\n    chroma,\n    normalized,\n    intervals\n  };\n}\n\nfunction listToChroma(set) {\n  if (set.length === 0) {\n    return EmptyPcset.chroma;\n  }\n\n  let pitch;\n  const binary = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // tslint:disable-next-line:prefer-for-of\n\n  for (let i = 0; i < set.length; i++) {\n    pitch = (0, _tonal.note)(set[i]); // tslint:disable-next-line: curly\n\n    if (pitch.empty) pitch = (0, _tonal.interval)(set[i]); // tslint:disable-next-line: curly\n\n    if (!pitch.empty) binary[pitch.chroma] = 1;\n  }\n\n  return binary.join(\"\");\n}"},"sourceMaps":{"js":{"mappings":[],"sources":{},"lineCount":null}},"error":null,"hash":"32d048f230a8bd4f1782fc9e07f4d066","cacheData":{"env":{}}}