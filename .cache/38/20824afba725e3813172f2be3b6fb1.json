{"id":"node_modules/@tonaljs/scale/dist/index.esnext.js","dependencies":[{"name":"/Users/kozbe/Desktop/playground/music-stuff/node_modules/@tonaljs/scale/dist/index.esnext.js.map","includedInParent":true,"mtime":499162500000},{"name":"/Users/kozbe/Desktop/playground/music-stuff/package.json","includedInParent":true,"mtime":1570751051894},{"name":"/Users/kozbe/Desktop/playground/music-stuff/node_modules/@tonaljs/scale/package.json","includedInParent":true,"mtime":1570750957251},{"name":"@tonaljs/array","loc":{"line":1,"column":44},"parent":"/Users/kozbe/Desktop/playground/music-stuff/node_modules/@tonaljs/scale/dist/index.esnext.js","resolved":"/Users/kozbe/Desktop/playground/music-stuff/node_modules/@tonaljs/array/dist/index.esnext.js"},{"name":"@tonaljs/chord-dictionary","loc":{"line":2,"column":24},"parent":"/Users/kozbe/Desktop/playground/music-stuff/node_modules/@tonaljs/scale/dist/index.esnext.js","resolved":"/Users/kozbe/Desktop/playground/music-stuff/node_modules/@tonaljs/chord-dictionary/dist/index.esnext.js"},{"name":"@tonaljs/pcset","loc":{"line":3,"column":48},"parent":"/Users/kozbe/Desktop/playground/music-stuff/node_modules/@tonaljs/scale/dist/index.esnext.js","resolved":"/Users/kozbe/Desktop/playground/music-stuff/node_modules/@tonaljs/pcset/dist/index.esnext.js"},{"name":"@tonaljs/scale-dictionary","loc":{"line":4,"column":48},"parent":"/Users/kozbe/Desktop/playground/music-stuff/node_modules/@tonaljs/scale/dist/index.esnext.js","resolved":"/Users/kozbe/Desktop/playground/music-stuff/node_modules/@tonaljs/scale-dictionary/dist/index.esnext.js"},{"name":"@tonaljs/tonal","loc":{"line":5,"column":32},"parent":"/Users/kozbe/Desktop/playground/music-stuff/node_modules/@tonaljs/scale/dist/index.esnext.js","resolved":"/Users/kozbe/Desktop/playground/music-stuff/node_modules/@tonaljs/tonal/dist/index.esnext.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extended = extended;\nexports.modeNames = modeNames;\nexports.reduced = reduced;\nexports.scale = scale;\nexports.scaleChords = scaleChords;\nexports.scaleNotes = scaleNotes;\nexports.tokenize = tokenize;\n\nvar _array = require(\"@tonaljs/array\");\n\nvar _chordDictionary = require(\"@tonaljs/chord-dictionary\");\n\nvar _pcset = require(\"@tonaljs/pcset\");\n\nvar _scaleDictionary = require(\"@tonaljs/scale-dictionary\");\n\nvar _tonal = require(\"@tonaljs/tonal\");\n\nconst NoScale = {\n  empty: true,\n  name: \"\",\n  type: \"\",\n  tonic: null,\n  setNum: NaN,\n  chroma: \"\",\n  normalized: \"\",\n  aliases: [],\n  notes: [],\n  intervals: []\n};\n/**\r\n * Given a string with a scale name and (optionally) a tonic, split\r\n * that components.\r\n *\r\n * It retuns an array with the form [ name, tonic ] where tonic can be a\r\n * note name or null and name can be any arbitrary string\r\n * (this function doesn\"t check if that scale name exists)\r\n *\r\n * @function\r\n * @param {string} name - the scale name\r\n * @return {Array} an array [tonic, name]\r\n * @example\r\n * tokenize(\"C mixolydean\") // => [\"C\", \"mixolydean\"]\r\n * tokenize(\"anything is valid\") // => [\"\", \"anything is valid\"]\r\n * tokenize() // => [\"\", \"\"]\r\n */\n\nfunction tokenize(name) {\n  if (typeof name !== \"string\") {\n    return [\"\", \"\"];\n  }\n\n  const i = name.indexOf(\" \");\n  const tonic = (0, _tonal.note)(name.substring(0, i));\n\n  if (tonic.empty) {\n    const n = (0, _tonal.note)(name);\n    return n.empty ? [\"\", name] : [n.name, \"\"];\n  }\n\n  const type = name.substring(tonic.name.length + 1);\n  return [tonic.name, type.length ? type : \"\"];\n}\n/**\r\n * Get a Scale from a scale name.\r\n */\n\n\nfunction scale(src) {\n  const tokens = Array.isArray(src) ? src : tokenize(src);\n  const tonic = (0, _tonal.note)(tokens[0]).name;\n  const st = (0, _scaleDictionary.scaleType)(tokens[1]);\n\n  if (st.empty) {\n    return NoScale;\n  }\n\n  const type = st.name;\n  const notes = tonic ? st.intervals.map(i => (0, _tonal.transpose)(tonic, i)) : [];\n  const name = tonic ? tonic + \" \" + type : type;\n  return { ...st,\n    name,\n    type,\n    tonic,\n    notes\n  };\n}\n/**\r\n * Get all chords that fits a given scale\r\n *\r\n * @function\r\n * @param {string} name - the scale name\r\n * @return {Array<string>} - the chord names\r\n *\r\n * @example\r\n * scaleChords(\"pentatonic\") // => [\"5\", \"64\", \"M\", \"M6\", \"Madd9\", \"Msus2\"]\r\n */\n\n\nfunction scaleChords(name) {\n  const s = scale(name);\n  const inScale = (0, _pcset.isSubsetOf)(s.chroma);\n  return (0, _chordDictionary.entries)().filter(chord => inScale(chord.chroma)).map(chord => chord.aliases[0]);\n}\n/**\r\n * Get all scales names that are a superset of the given one\r\n * (has the same notes and at least one more)\r\n *\r\n * @function\r\n * @param {string} name\r\n * @return {Array} a list of scale names\r\n * @example\r\n * extended(\"major\") // => [\"bebop\", \"bebop dominant\", \"bebop major\", \"chromatic\", \"ichikosucho\"]\r\n */\n\n\nfunction extended(name) {\n  const s = scale(name);\n  const isSuperset = (0, _pcset.isSupersetOf)(s.chroma);\n  return (0, _scaleDictionary.entries)().filter(scale => isSuperset(scale.chroma)).map(scale => scale.name);\n}\n/**\r\n * Find all scales names that are a subset of the given one\r\n * (has less notes but all from the given scale)\r\n *\r\n * @function\r\n * @param {string} name\r\n * @return {Array} a list of scale names\r\n *\r\n * @example\r\n * reduced(\"major\") // => [\"ionian pentatonic\", \"major pentatonic\", \"ritusen\"]\r\n */\n\n\nfunction reduced(name) {\n  const isSubset = (0, _pcset.isSubsetOf)(scale(name).chroma);\n  return (0, _scaleDictionary.entries)().filter(scale => isSubset(scale.chroma)).map(scale => scale.name);\n}\n/**\r\n * Given an array of notes, return the scale: a pitch class set starting from\r\n * the first note of the array\r\n *\r\n * @function\r\n * @param {string[]} notes\r\n * @return {string[]} pitch classes with same tonic\r\n * @example\r\n * scaleNotes(['C4', 'c3', 'C5', 'C4', 'c4']) // => [\"C\"]\r\n * scaleNotes(['D4', 'c#5', 'A5', 'F#6']) // => [\"D\", \"F#\", \"A\", \"C#\"]\r\n */\n\n\nfunction scaleNotes(notes) {\n  const pcset = notes.map(n => (0, _tonal.note)(n).pc).filter(x => x);\n  const tonic = pcset[0];\n  const scale = (0, _array.sortedUniqNoteNames)(pcset);\n  return (0, _array.rotate)(scale.indexOf(tonic), scale);\n}\n/**\r\n * Find mode names of a scale\r\n *\r\n * @function\r\n * @param {string} name - scale name\r\n * @example\r\n * modeNames(\"C pentatonic\") // => [\r\n *   [\"C\", \"major pentatonic\"],\r\n *   [\"D\", \"egyptian\"],\r\n *   [\"E\", \"malkos raga\"],\r\n *   [\"G\", \"ritusen\"],\r\n *   [\"A\", \"minor pentatonic\"]\r\n * ]\r\n */\n\n\nfunction modeNames(name) {\n  const s = scale(name);\n\n  if (s.empty) {\n    return [];\n  }\n\n  const tonics = s.tonic ? s.notes : s.intervals;\n  return (0, _pcset.modes)(s.chroma).map((chroma, i) => {\n    const modeName = scale(chroma).name;\n    return modeName ? [tonics[i], modeName] : [\"\", \"\"];\n  }).filter(x => x[0]);\n}"},"sourceMaps":{"js":{"mappings":[],"sources":{},"lineCount":null}},"error":null,"hash":"c5b6f61ce73014a57ae66dc6efb6a7d5","cacheData":{"env":{}}}